# 💊 약통 무게 기반 복약 관리 + 의약품 지식 LLM + 처방약 OCR 스케줄러

**“약통 무게 + 의약품 지식 + OCR 인식으로 복약 관리 전 과정을 자동화”**

- 로드셀 센서로 **무게 기반 복용 여부 자동 판단**  
- **일반의약품 데이터 기반 LLM Q&A (OTC-QA)**  
- **처방전 사진 촬영 → OCR → 자동 스케줄 등록**  
- 미복용 시 **푸시 알림**, 기록은 **클라우드 저장/보호자 공유**  
- 노인, 어린이, 만성질환자 대상 **안전한 복약 관리 지원**

---

## ✅ 전체 아키텍처 구성

```
[약통 + 로드셀(HX711)] 로드셀 + 필터 대신 아두이노 써도 됨
      ↓ (Python + EWMA 필터)
[라즈베리파이: 무게 측정 + Django 전송]
      ↓
[Django 서버 (REST API)]
   ├─ AI 모듈 (복용 여부 판별, 미복용 확률 예측)
   ├─ OTC-QA 모듈 (일반의약품 LLM + RAG 질의응답)
   └─ OCR 모듈 (처방전 텍스트 인식 → 복약 스케줄 자동 등록)
      ↓
[Firebase FCM → Kotlin 안드로이드 앱]
```
---  

## ✅ 역할 분담

| 구성 | 사용 기술 | 주요 역할 |
| --- | --- | --- |
| 라즈베리파이 | Python, HX711 드라이버, HTTP/MQTT | - 무게 측정·신호 전처리(EWMA)<br>- Django 서버로 전송 |
| 백엔드 서버 | Django + DRF, PostgreSQL, Redis, Celery | - 무게 기반 AI 판별<br>- OTC-QA 질의응답 (RAG)<br>- OCR 처방 파싱 → 복약 일정 생성<br>- 푸시 알림 전송 |
| 모바일 앱 | Kotlin(Compose), Retrofit, Room, FCM | - 복약 정보·스케줄 확인<br>- OTC-QA 질문 UI<br>- 알림 수신 및 기록 확인 |

---

## ✅ 🎯 AI 주요 기능

1. **무게 기반 복용 여부**  
   - 단순 감량 탐지 X → 패턴 학습  
   - `진짜 복용` vs `뚜껑 열림/노이즈` 구분  
   - 오탐 최소화, 정확한 기록 확보  

2. **미복용 확률 예측**  
   - 개인별 과거 기록 기반 확률 계산  
   - `"오늘 저녁 복용 놓칠 확률 = p(miss)"`  
   - 알림 강도·시간 조절 가능  

3. **개인화 알림 최적화**  
   - 평소 복용 시간/습관 학습  
   - 반응률 높은 시간대에 맞춰 알림 전송  

4. **OTC-QA (일반의약품 질의응답)**  
   - 데이터 소스: 식약처(e약은요), HIRA, 약학정보원  
   - 예: “타이레놀 최대 복용량?” → 출처와 함께 답변  
   - 안전 가드레일: 임산부, 소아, 중복성분 자동 경고  

5. **처방약 OCR 스케줄러**  
   - 처방전 사진 → OCR → 용법 파싱  
   - 예: `500mg 1정 1일 3회 5일간` → 자동 RRULE 생성  
   - 앱에서 스케줄 확인 및 알림 동기화  
   - 모호한 용법(“필요시”)은 사용자 확인 필수  

---

## ✅ 핵심 플로우

- **무게 변화 감지** → 복용 여부 판별 → 기록 저장  
- **OTC-QA 질의응답** → LLM + RAG 답변 + 출처 제공  
- **처방전 촬영** → OCR 인식 → 파싱 → 스케줄 자동 등록  
- **FCM 알림** → 사용자 복약 알림 + 보호자 공유  

---

## ✅ 실패·예외 처리

### 센서/라즈베리파이
- 무게 읽기 실패: 3회 재시도 후 로컬 큐 저장 → 재전송  
- 드리프트/영점 이탈: 자동 재영점화, 수동 캘리브레이션 지원  
- 스파이크 노이즈: EWMA + 중앙값 필터로 제거  

### 네트워크/전송
- HTTP 타임아웃 시 지수 백오프, 최대 5회  
- 장기 연결 불가 시 MQTT 폴백  
- 중복 전송 방지: event_id(UUID) 기반 UPSERT  

### 서버/API
- 입력 검증: 단위·타임존 강제  
- 트랜잭션: Regimen ↔ DoseEvent 원자적 처리  
- 인증: 디바이스 토큰 회전, 재사용 방지 nonce 검증  
- 작업 큐: Celery 재시도(지수+랜덤 지터), DLQ 격리  

### 알림/앱
- 무효 토큰: 즉시 제거  
- 알림 실패 시 사용자 앱 로컬 알림 폴백  
- OCR 실패: 대비/샤프닝 후 재시도, 최종적으로 사용자 수동 입력 유도  
- 모호한 용법(“필요시”) → 기본 비활성화 후 사용자 확인 요청  

---

## ✅ 주의사항
- 본 시스템은 **의학적 진단·처방을 대체하지 않음**  
- 의약품 관련 답변은 항상 **공식 데이터 출처**와 함께 제공  
- 개인 정보와 의료 데이터는 암호화 저장 및 일정 기간 후 파기

---

# 🧠 객체 인식 기반 사용주기 트래커

**“휴대폰 카메라로 물건을 스캔하면 AI가 동일 물건을 재식별하고 ‘사용 세션’과 주기를 자동 기록”**

- 태그 없이 카메라만 사용
- 물건 등록(다각도 사진) → 이후 스캔 시 자동 매칭
- 세션 간격으로 **사용주기** 계산, 30·60·90일 미사용 알림
- 중고/기부 추천 연동 가능

---

## ✅ 전체 아키텍처 구성도

```
scss
[모바일 앱(카메라)]
   ├─ 객체 탐지(경량 YOLO/SSD)
   ├─ 임베딩 추출(CLIP/MobileNet)
   └─ 후보 매칭(FAISS/KNN)
        ↓
[로컬 DB(SQLite) & 임베딩 인덱스]
        ↓
[AI 모델: 재식별(Re-ID) & 주기 추정(생존분석/통계)]
        ↓
[대시보드/알림/중고·기부 연동]
```

---

## ✅ 구성 요소별 역할 분담 (표)

| 구성요소 | 사용 기술 | 주요 역할 |
| --- | --- | --- |
| **모바일 카메라** | Android(Kotlin), CameraX | 실시간 캡처, 품질체크(흐림/역광) |
| **객체 탐지** | TFLite YOLO-n/SSD | bbox 추출, 다중 객체 처리 |
| **임베딩·Re-ID** | MobileCLIP/ViT-tiny, FAISS | 동일 물건 매칭, 후보 상위 k 제시 |
| **주기 추정** | Python/TFLite, 통계(중앙값·EMA), Weibull/Cox | 사용 세션 간격→사용주기·다음 사용일 예측 |
| **로컬 저장소** | SQLite(+BLOB), 암호화 | 아이템, 임베딩, 세션 로그 저장 |
| **앱 UI/알림** | Kotlin, FCM | 등록·스캔·대시보드·미사용 알림 |
| **외부 연동(옵션)** | 중고/기부 API | 처분·판매·기부 워크플로우 |

---

## 서비스에서 AI 활용 방안

### 1. **객체 인식**

- 경량 탐지기로 물건 bbox 추출
- 품질 분류(CNN)로 흐림/노출 불량 시 재촬영 유도

### 2. **재식별(Re-ID)**

- 물건 임베딩(256~512D) 생성 → FAISS로 최근접 검색
- 유사 물건 혼동 시 **상위 3개 후보** 제시 후 1탭 확정
- 라벨/로고 크롭 임베딩 추가로 구분 강화

### 3. **사용주기 산출**

- 스캔 시점들을 **세션**으로 기록
- 간격의 중앙값/가중평균(EMA) + 생존분석(Weibull/Cox)로
    - `평균 사용주기`, `다음 사용 예상일`, `장기 미사용 확률` 계산

### 4. **맞춤 인사이트**

- “DIY 드라이버 평균 주기 41일”
- “요가매트 60일 미사용 → 처분 후보”
- “책 카테고리 중 40% 90일 미사용”

---

## 데이터 구조(요약)

- `items(id, name, category, embed, photos[], created_at)`
- `sessions(id, item_id, ts, source: 'scan|batch')`
- `stats(item_id, last_used, mean_period, next_pred_date, unused_30/60/90)`

---

## 앱 사용 흐름

1. **등록**: 물건 3~5각도 촬영 → 이름·카테고리 자동 제안 → 저장
2. **스캔**: 선반/서랍을 비추고 촬영 → 자동 매칭 → 세션 기록
3. **대시보드**: 최근 사용일, 평균 주기, 미사용 경고, 처분 제안
4. **배치 스캔(옵션)**: 짧은 동영상→키프레임 1fps 추출→대량 인식

---

## 프라이버시·오프라인

- 온디바이스 추론 기본. 원본 이미지는 로컬 암호화 저장
- 클라우드 동기화는 임베딩·통계만 선택

---

## 2개월 MVP 범위

- 탐지(TFLite) + 임베딩 + FAISS 매칭
- 등록·스캔·세션 기록 + 주기 계산(통계형)
- 30·60·90일 미사용 알림, 대시보드
- 품질체크, 상위 후보 3개 교정 UX

---

## 리스크와 대응

- **유사 물건 다수**: 라벨/로고 크롭 임베딩, 사용자 1탭 확정
- **조명 변동**: 밝기 정규화, 색 히스토그램 보조특징
- **콜드스타트**: 초기 1~2주 스캔 빈도 알림로 데이터 축적

# 📊 난이도 측정 (1=쉬움 ~ 5=어려움)

| 항목 | 종합 난이도 | AI 난이도 | HW/IoT | 앱/백엔드 | 데이터/라벨 | 2개월 MVP 가능성 |
| --- | --- | --- | --- | --- | --- | --- |
| 💊 약통 무게 복약(+OTC-QA+OCR) | **3.0** | 3.0 | 2.5 | 3.0 | 2.5 | 보통~높음 |
| 🧠 객체 인식 사용주기 | **3.5** | 3.5 | 1.0 | 2.5 | 3.0 | 보통~높음 |

---

# 🔧 병목 · 단순화 팁

- 💊 **약통 무게 복약 (+OTC-QA + OCR)**  
  - **센서 처리**: EWMA + 피크 검출 규칙형 → 기본 정확도 확보  
  - **AI 판별**: 1D CNN 추가 → ‘뚜껑 열림/진동’ 오탐 제거  
  - **OTC-QA**: LLM 직접 학습 대신 **RAG** 활용 (데이터 구축 부담↓)  
  - **OCR**: MLKit/Tesseract + 정규식 파싱으로 시작, 복잡한 문장은 사용자 확인 필수  
  - **알림**: FCM 기본 기능만 적용 → 개인화 최적화는 후순위  

- 🧠 **객체 인식 사용주기**  
  - YOLO-n + MobileCLIP 임베딩 + FAISS로 MVP 구축  
  - 사용주기 계산은 **EMA/중앙값** 우선 적용 → 생존분석은 이후 확장  
  - 유사 물건 혼동은 **후보 상위 3개 교정 UX**로 단순화  
